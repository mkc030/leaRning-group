---
title: "Useful R functions to remember"
author: "Michelle Coombe"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
options(digits=3)
```

## Useful R and related references

### Overleaf
This is an online LaTeX writing and publishing tool, and has different modes depending on your expertise level with LaTeX. https://www.overleaf.com/for/authors Free for personal use :) It does however, only generate a PDF rather than a word doc, which can be an issue for submitting to certain journals.

## Useful math, stats, and summarizing functions

#### Determining the minimium of multiple numbers in a vector
Min() or max() give you ONE output for a vector, while pmin() or pmax() can give you MULTIPLE  outputs, depending on the length of the input. From ?pmin help documentation:
```{r}
5:1
min(5:1, pi)  #Provides ONE output number
pmin(5:1, pi) # Provides 5 output numbers
```
This can be useful when trying to determine a new column based on several possible input values, kinda like an if_else statement but using max or min rather than logical evaluators. See Dr. Caroline Colijn's example using data from Tianjin. 
```{r}
tdata=read.csv("Documents/R projects for laptop/EpiCoronaHack_Cluster/Tianjin135casesFeb22.csv",na.strings = "", stringsAsFactors = F)
tdata$symptom_onset=as.Date(tdata$symptom_onset, format = "%d/%m/%Y")
tdata$start_source=as.Date(tdata$start_source, format = "%d/%m/%Y")
tdata$end_source=as.Date(tdata$end_source,format = "%d/%m/%Y" )
tdata$confirm_date=as.Date(tdata$confirm_date,format = "%d/%m/%Y" )

tdata$end_source[which(is.na(tdata$end_source))]=tdata$symptom_onset[which(is.na(tdata$end_source))]  # if no end exposure: set to symptom onset 
tdata$end_source = pmin(tdata$end_source, tdata$symptom_onset) # if end exposure after onset, set to onset 
```

#### Getting stats info out of plot objects
You can get info out of (?some) plot objects without plotting it
For example, to get the 5 number summary from a boxplot (numbers between 0 and 100 rather than 0 and 1)
```{r boxplot summary}
boxplot(gapminder$lifeExp, plot = F)$stats
```
Cool!!! Good to remember that making the graph is actually a (desired) side effect of making the boxplot object

#### Comparing doubles and integers
Recall that `identical()` is very strict and does not convert between different classes, so `dplyr::near()` may be a better option.

## Useful data wrangling functions
#### Printing more lines to console than what it automatically gives you
You need to make the data frame into a tibble and then use the print function to specify the number of rows. You can also use the options in `print` to change the max number of extra columns to print abbreviated information for if the width of the console isn't wide enough.
```{r printing more rows}
# Default max is 20 rows
print(as.tibble(iris))

# Print 3 rows
print(as_tibble(iris), n = 3)

# Print 30 rows
print(as_tibble(iris), n = 30)
```

#### Moving around columns in your data frame
Move one (or a few) column to the front of your dataframe. For instance, you just joined data and you want the sample ID, date and wetland as the first three columns to make it easier to read when extracting certain rows or something. Use `dplyr::select(special_var, everything())`, where `special_var` would be 'sampleID' or 'c(sampleID, date_col, wtld)' or whatever is the column you want first. You could also do `dplyr::select(special_var, -everything()` if you want only the `special_var` selected from your data frame. 

#### Filtering to multiple rows based on min or max ranks
To get rows from a dataframe with the minimum or maxium value (based on rank) of a certain variable - use dplyr's `min_rank` in combination with `filter`. The advantage is that you don't just get the sole minimum or maximum rank (eg with `min` or `max`) but instead can specify the bottom or top of any 'n' value (i.e. top 5). You could also use grouping variables (e.g. country) to get the top/bottom 5 rows within a country for that variable. 
```{r min rank ex}
library(gapminder)
#Method 2 (using dplyr and putting everything into one table:)
  gapminder %>% 
   filter(min_rank(gdpPercap) <= 5 | min_rank(desc(gdpPercap)) <= 5) %>% 
   arrange(gdpPercap)
```

#### Determining which integers represent levels of a factor
You can use `unclass` to determine which integers represent which levels for a factor class variable. Helpful for troubleshooting characters vs. factors and the messes they can get you into...
```{r unclass ex}
# Create a new dataframe from subset of gapminder
mini_gap <- gapminder %>% 
  filter(country %in% c("Belgium", "Canada", "United States", "Mexico"), year > 2000) %>% 
  select(-pop, -gdpPercap) %>% 
  droplevels()

# Use unclass to see how R represents the country levels internally
unclass(mini_gap$country)
```


#### Renaming
To name something (especially in a function) use `setNames`. If used in a function, do this **LAST** as it will both set the names of the object and then RETURN the object. See example under ?setNames.

#### Lists: determining the number of elements at each level in a list
Use `map_int` from purrr package which returns and integer and preserves the NAME of element in the list (unlike lapply). The function you apply can be `length` (for a list of vectors, as below), or `nrow` if you have a list of data frames with multiple columns (as length would just count all the elements from top L to bottom R within that data frame).
```{r}
uneven_list <- list("a" = c(1, 2, 3), "b" = c(1:10), "c" = c(5:11))
map_int(uneven_list, length) #Or use 'nrow' instead of length for data frames
```

## Useful data visualization functions

