---
title: "Useful R functions to remember"
author: "Michelle Coombe"
date: "26/02/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
options(digits=3)
```

## Useful R and related references

### Overleaf
This is an online LaTeX writing and publishing tool, and has different modes depending on your expertise level with LaTeX. https://www.overleaf.com/for/authors Free for personal use :) It does however, only generate a PDF rather than a word doc, which can be an issue for submitting to certain journals.

## Useful math and summarizing functions

#### Determining the minimium of multiple numbers in a vector
Min() or max() give you ONE output for a vector, while pmin() or pmax() can give you MULTIPLE  outputs, depending on the length of the input. From ?pmin help documentation:
```{r}
5:1
min(5:1, pi)  #Provides ONE output number
pmin(5:1, pi) # Provides 5 output numbers
```
This can be useful when trying to determine a new column based on several possible input values, kinda like an if_else statement but using max or min rather than logical evaluators. See Dr. Caroline Colijn's example using data from Tianjin. 
```{r}
tdata=read.csv("Documents/R projects for laptop/EpiCoronaHack_Cluster/Tianjin135casesFeb22.csv",na.strings = "", stringsAsFactors = F)
tdata$symptom_onset=as.Date(tdata$symptom_onset, format = "%d/%m/%Y")
tdata$start_source=as.Date(tdata$start_source, format = "%d/%m/%Y")
tdata$end_source=as.Date(tdata$end_source,format = "%d/%m/%Y" )
tdata$confirm_date=as.Date(tdata$confirm_date,format = "%d/%m/%Y" )

tdata$end_source[which(is.na(tdata$end_source))]=tdata$symptom_onset[which(is.na(tdata$end_source))]  # if no end exposure: set to symptom onset 
tdata$end_source = pmin(tdata$end_source, tdata$symptom_onset) # if end exposure after onset, set to onset 
```

## Useful data wrangling functions

Move one (or a few) column to the front of your dataframe. For instance, you just joined data and you want the sample ID, date and wetland as the first three columns to make it easier to read when extracting certain rows or something. Use `dplyr::select(special_var, everything())`, where `special_var` would be 'sampleID' or 'c(sampleID, date_col, wtld)' or whatever is the column you want first.

To get rows from a dataframe with the minimum or maxium value (based on rank) of a certain variable - use dplyr's `min_rank` in combination with `filter`. The advantage is that you don't just get the sole minimum or maximum rank (eg with `min` or `max`) but instead can specify the bottom or top of any 'n' value (i.e. top 5). You could also use grouping variables (e.g. country) to get the top/bottom 5 rows within a country for that variable. 
```{r min rank ex}
library(gapminder)
#Method 2 (using dplyr and putting everything into one table:)
  gapminder %>% 
   filter(min_rank(gdpPercap) <= 5 | min_rank(desc(gdpPercap)) <= 5) %>% 
   arrange(gdpPercap)
```

You can use `unclass` to determine which integers represent which levels for a factor class variable. Helpful for troubleshooting characters vs. factors and the messes they can get you into...
```{r unclass ex}
# Create a new dataframe from subset of gapminder
mini_gap <- gapminder %>% 
  filter(country %in% c("Belgium", "Canada", "United States", "Mexico"), year > 2000) %>% 
  select(-pop, -gdpPercap) %>% 
  droplevels()

# Use unclass to see how R represents the country levels internally
unclass(mini_gap$country)
```

To name something (especially in a function) use `setNames`. If used in a function, do this **LAST** as it will both set the names of the object and then RETURN the object. See example under ?setNames.