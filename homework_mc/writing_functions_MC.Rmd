---
title: "Functions in R"
author: "Michelle Coombe"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
### Load libraries and data
```{r}
library(tidyverse)
library(gapminder)
library(lubridate)
```
Notes in this document are primarily from the original [stat545](https://stat545.com/functions-part1.html), but also from the R for Data Science [ebook](https://r4ds.had.co.nz/functions.html), and the newer [ubcstat545](https://stat545guidebook.netlify.com/functional-programming-in-r-part-i.html).

## Random notes to help understand how R works with functions

### Indexing and vectorized operations
Using square brackets to isolate elements of a vector = indexing. Index value begin at '1' in R, which seems obvious, but apparently most other languages start at '0'. 

Most operations in R are *vectorized*, meaning that by default they will happen component-wise when given a vector as an input. This is very useful to understand as it avoids a lot of unnecessary `for` loops!
```{r Vectorizing ex}
x <-  1:4

#Vectorized version of squaring 'x'
(y <- x^2)

#For loop version of squaring 'x'
  #Need something for the results of the for loop to be placed into
z <- vector(mode = mode(x), length = length(x))
z

for (i in seq_along(x)) {
  z[i] <- x[i]^2
}

#These end up with the same result
identical(y, z)
```

However, be unaware of vectorizing can also lead to traps, as (a) it can lead to unexpected results if you don't intend for this behaviour, and (b) it means that R will recycle vectors if they are not of the necessary length. It is good practice to check your R objects to make sure they are what you expect in terms of outputs, flavors, and length/dimensions!
```{r Recycling vectors}
(y <-  1:3)
(z <- 3:7)

y + z #R will warn you of uneven lengths here

(y <- 1:10)
(z <- 3:7)

y + z #But not here...I think because length(y) is a multiple of length(z)...but this is bad news!
```

#### Logical evaluations, if statments, and vectorization
The `|`, `&` and `==` evaluators are vectorized and apply to multiple values and should never be used in programming control flow and certain conditional statements (e.g. `if()`). 
Instead, you can use `||` and `&&` where the double operators returns `TRUE` for the first instance of `TRUE` it sees, and returns `FALSE` for the first instance of `FALSE` it sees. The double operators are "short circuits". Thus, while the single sign version compares at each element (i.e. is vectorized), while the double sign evaluates from left to right, examining only the first element of each vector, and evaluation stops once a result is determined.
In terms of output, the short form will result in a logical vector, while the double operators will return only one value. `if()` statements need a result of length 1 and will not work with a logical vector, hence why you should never use the single operators. However, a logical vector would be appropriate to an `ifelse()` statement.
```{r}
c(T, T, F) & c(T, F, F)
c(T, T, F) && c(T, F, F)
c(T, T, F) | c(T, F, F)
c(T, T, F) || c(T, F, F)

#example of short-circuiting (i.e. only evaluating as many terms as they need to get a result)
a
TRUE || a
FALSE || a
TRUE | a
FALSE & a
```
Alternatively, you can use `any()` or `all()` to collapse a vector (logical for `|` or `&`, or any type for `==` equivalencies) down to a single value. Another alternative for determining equivalency is to use `identical()`, although it is very strict and will not convert between different types (i.e. `identical(1L, 1)` returns `F`) and measures down to smallest possible value for integers and doubles, so use with caution! For comparing integers and doubles, `dyplyr::near()` may be a better option.

Don't forget that `TRUE` coerces to 1 and `FALSE` coerces to 0.

### Lists: 
Lists are like a vector but do not require that the elements are of the same flavor Data frames are a special case of a list where each element is an atomic vector, and all elements have the same length. Many functions will return lists to you and you will want to get at the list's innards. The components of a list also have names, and you can create or change names using the `names` function. 

Extracting elements from a list. See R for Data Science's [condiments](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) section for great visual overview (also section 20.5.2 above the pepper shaker bit is quite useful too). Note that you have to use the double bracket approach, as opposed to the dollar sign, when the indexing object itself is an R object (eg "iWantThis" in the example below. Additionally, if you want more than one element, you must use vector-style indexing with **single** square brackets: this will always return another list (even if you request only 1 element). If you subset using double square brackets (for ONE element) you will be the flavor of that element.

Summary of how to extract using square brackets:

* x[1] returns the first element (eg data frame) in a list, still surrounded by a list wrapper

* x[[1]] returns only the first element (eg the data frame itself), without a list wrapper

* x[[1]][1] returns the first element of the data frame within our list, surrounded by a list wrapper

* x[[1]][[1]] returns the first element of the data frame within our list, without the list or data frame wrappers
```{r examples of how to extract elements from a list}
(a <- list(veg = c("cabbage", "eggplant"),
           tNum = c(pi, exp(1), sqrt(2)),
           myAim = TRUE,
           joeNum = 2:6))

# Explore this list
str(a)
length(a)
class(a)
mode(a) #Note this tells you the STORAGE mode, not the statistical mode!!!!

#Ways to get to a single element
a[[2]]    #index with a positive integer
a$myAim   #use dollar sign and element name
str(a$myAim) #we get myAim itself, a length of 1 logical vector
a[["tNum"]]  #index with a length 1 character vector
str(a[["tNum"]])  #we get tNum itself, a length 3 numeric vector
iWantThis <- "joeNum"  #indexing with a length 1 character object
a[[iWantThis]]  #we get joeNum itself, a length 5 integer vector
# a[[c("joeNum", "veg")]]  #This does NOT work!!! Can't get >1 elements!!! Can't knit with the operation either...

#Ways to get multiple elements
names(a)
a[c("tNum", "veg")]   #indexing by length 2 character vector
str(a[c("tNum", "veg")])  #Returns a list of length 2
str(a["veg"])   #returns a list of length 1
length(a["veg"])
length(a["veg"][[1]])  #contrast with the length of the veg vector itself
```

### Matrices and data flavors: 
A matrix is an alternative to data frames for storing rectangular data. Matrices are generalizations of atomic vectors, so all elements must be of the same class. Indexing is similar to that of a vector or a list, except that you can use `[i, j]`, where `i` = row and `j` = column. You can fill a matrix with a vector, by giving row and column numbers (and names) at creation. If the input vector is not long enough, R will recycle it.
```{r making matrices from vectors}
matrix(1:15, nrow = 5)
matrix("yo!", nrow = 3, ncol = 6)
matrix(c("yo!", "foo?"), nrow = 3, ncol = 6)
matrix(1:15, nrow = 5, byrow = TRUE)
matrix(1:15, nrow = 5,
       dimnames = list(paste0("row", 1:5),
                       paste0("col", 1:3)))
```

Note that if your elements are not of the same flavor, it may either convert everything to the lowest common flavor (usually character), or you will either get an error, or R can silently fail. This is why it is really important to understand the data flavors in your objects!!!
```{r }
multiDat <- data.frame(vec1 = 5:1,
                       vec2 = paste0("hi", 1:5))
str(multiDat)
(multiMat <- as.matrix(multiDat))
str(multiMat)  #Oh bad news - first element is now just 'NULL' instead of integers...
```

Table of atomic R object flavors (very handy!!!)
*Note the following will look great when rendered with pandoc but terrible in html, but is a good example of how to make a text table with centered values*
|:---------:|:-------------:|:---------:|:---------:|
| "flavor"  | type reported | mode()    | class()   |
|           | by typeof()   |           |           |
| character | character     | character | character |
| logical   | logical       | logical   | logical   |
| numeric   | integer       | numeric   | integer   |
|           | or double     |           | or double |
| factor    | integer       | numeric   | factor    |

```{r atomic R object flavors}
# Legible in any format
#  +-----------+---------------+-----------+-----------+
#  | "flavor"  | type reported | mode()    | class()   |
#  |           | by typeof()   |           |           |
#  +===========+===============+===========+===========+
#  | character | character     | character | character |
#  +-----------+---------------+-----------+-----------+
#  | logical   | logical       | logical   | logical   |
#  +-----------+---------------+-----------+-----------+
#  | numeric   | integer       | numeric   | integer   |
#  |           | or double     |           | or double |
#  +-----------+---------------+-----------+-----------+
#  | factor    | integer       | numeric   | factor    |
#  +-----------+---------------+-----------+-----------+
```

## Control structure and conditional statements: If, Ifelse, else, Switch and Cut functions
Conditional statements are useful to controling how and when certain expressions are evaluted such as *if* `if(condition) { expression }`. If the condition of the *if* statment evaluates to FALSE, then the following expression is NOT executed and you will not get your result. If you want something done if the *if* condition evaluates to FALSE you can also add *else* `if(condition) { expr1 } else { expr2 }`, and/or *else if* `if(condition) { expr1 } else if(condition2) { expr2 } else { expr3 }` . Note that the `else` keyword **must** be on the same line as the closing bracket of the `if` statement!

A very important note with *if*, *else if*, and *else* statements is that R will execute through the code until it hits the **first condition** which evaluates to TRUE, then stops and does NOT execute the rest of the code. This is very important to keep in mind if you've made statements that are not mutuatally exclusive!!!

If you are getting confused about how your conditional statement is being evaluated, substitute your desired result with text and a print statement, so that you can see where in the conditional statement your results are being evaluated from (and if it is working as expected or not!!!)
```{r Trouble-shooting ifelse statements}
number <- 56

if(number < 10){
  if(number < 5){
    result <- "extra small"
  } else {
    result <- "small"
  }
  } else if(number < 100) {
    result <- "medium"
  } else {
    result <- "large"
  }
  print(result)
```

Alternatively, if you only have 2 conditions, you can just use an `ifelse` statement rather than `if` then `else` statements. The format is: ifelse(condition.to.test, yes = return.value.if.T, no = return.value.if.F). Note that this function strips attributes (e.g. class) from the input, so use caution or (better yet) do NOT use with dates or factors.
```{r ifelse ex}
x <- c(6:-4)
ifelse(x >= 0, sqrt(x), NA) #note you will get a warning that NaNs are produced
sqrt(ifelse(x >= 0, x, NA)) #notice that you will NOT get a warning that NaNs are produced here
```

However, if you are writing a long series of chained *if* statements, you should instead consider using alternative functions.  

* `switch` evaluates selected code based on position or name. Format is: `switch(object, case = action)`
```{r switch ex}
basic_maths <- function(x, y, op) {
                  switch (op,
                    plus = x + y,
                    minus = x - y,
                    times = x * y,
                    divide = x / y,
                    stop("Unknown op!")
                  )
                }

basic_maths(x = 10, y = 5, op = "times")
```

* `cut` is useful to turn continuous variables into discrete categories. The argument 'breaks' can be supplied as a single number (which divides the data into n = break pieces of equal length) or a numeric vector of two or more unique cut points. The 'right' argument (default = T) specifies if intervals should be closed on the right and open on the left, or vice versa. There is also a 'labels' argument. Finally, note that there is also a `cut.Date` function for class 'Date' or 'POSIXt' objects. Note that 'cut.Date' does NOT work on date 'Interval' class.
```{r cut ex}
Z <- 1:100
table(cut(Z, breaks = 5, labels = F))
table(cut(Z, breaks = 5))
table(cut(Z, breaks = 5, right = F))


mydates <- seq(from = ymd("2016-09-01"), to = ymd("2018-08-30"), by = "week")
table(cut.Date(mydates, breaks = "month")) 
table(cut.Date(mydates, breaks = "month", labels = F)) 
```

* `stopifnot` is useful to check the validity of arguments. For instance, is your input numeric as expected? Are there NAs that need to be removed? Recall that `stopifnot` is evaluating if something is TRUE rather than you asserting what might be wrong.
```{r stopifnot ex}
# Simple example
mmm <- function(x){
  stopifnot(is.numeric(x))
  max(x) - min(x)
}

mmm(gapminder$country)

# More complex example
wt_mean <- function(x, w, na.rm = FALSE) {
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}

wt_mean(1:6, 6:1, na.rm = "foo")
```

## Outline for writing your own function
When to write a function? The general rule of thumb seems to be if you've copied and pasted code 3 or more times. Yes, copy and paste is fast, but it is also WAY more prone to unnotice errors and will cause headaches down the line!!!

The process for writing a function follows the idea of building a minimum viable product: a limited-but-functioning thing is still very useful and easier to build into a more complex thing than just building the more complex thing straight from scratch. 

DRY principle: "do not repeat yourself". The more repetition is in your code, the more likely you will forget to update everything when things change. Be kind to collaborators and future you.

General function writing steps are as follows:

1. Develop some working, interactive code. 

  i) This means that you start with a **simple** problem (or multiple simple problems). It is really important that you know what to expect for your output (e.g. data flavor, length, possible values)!!!
```{r Function ex step 1.i}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

# Goal = to rescale each column!
```
  
  ii) Then develop a working snippet of code that solves this problem(s). 
```{r Function ex step 1.ii}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))  #Notice the copy and paste mistake here!!!
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```
  
  iii) Test the snippet of code with test data, including some unexpected values (e.g. NAs, values outside of expected range, different flavors of data, different data types (vector vs data frame vs list)). This will give you an idea of when/where it might fail and if it fails, what you expect it to do. More on testing later.
```{r Function ex step 1.iii}
#No ex here as actually 'R for data science' does this testing step at the end of writing a function...
#But how much/when you test during and after making a function probably depends on its complexity
```

2. Rewrite your snippet of code to use temporary variables. These temporary variables should be used where elements of code are repeated and/or when inputs are needed. Make sure to use **clear** names, not just a letter (in most cases) as it makes trouble-shooting down the line more difficult and readability for other users (i.e. future you!) much more difficult.
```{r Function ex step 2.i}
# Start by focusing on only one column in the dataset
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

* Use temporary variables for the inputs; you can start with a very short, generic name to see where the inputs are (i.e. 'x') and then re-write the variable names for clarity
```{r Function ex step 2.ii}
# Figure out the inputs and replace with temporary variables
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))

#Now you can see you are actually calculating the range three times!!! This leads to step 3
```

* Final variable names for inputs (aka argmuments) should be nouns

3. Re-write your code for clarity. For instance, pull out the intermediate calculations into named variable to simplify the code. This makes it much more clear what the code is doing!
```{r Function ex step 3}
# Pull out intermediate calculations into a named variable (e.g. we are calculating the range)
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```


4. NOW turn your code snippet into a function by adding the `function(arguments) {}` part. Recall that the value of the last evaluated expression will be returned; however, if you call `return` within the function, that expression will be evaluated, the value returned, and the function will stop here (so **careful** if/where you use return calls!!!)

  i) Pick a descriptive name for your function. Function names should generally be verbs (although sometimes a noun may be more appropriate if your verb is very broad (e.g. get, compute, determine, calculate) For instance, 'get_mean()' probably should just be 'mean()'. Seperate words with an underscore (note that I've also seen R style guides say that words in objects and function should be seperated with a period...so just pick a convention and be consistent.) Reminder that function argument names can be anything but convention is to use meaningful names and if you are reusing functions or arugments in other functions, use the same names just to make it easier to remember (e.g. input_animals, input_inverts, input_plants vs. plants_input, inverts_input, plants_input).
  
  ii) List the inputs (aka arguments) inside the function, for instance `function(x, y, z)`.
  
  iii) Place the working snippet of code inside the body of the functions (aka in the `{}` part)
  
```{r Function ex step 4}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

5. Test that new function! 

  i) Use on some test data that mimics your intended data and where you (roughly) know what it should return.
  
  ii) Use on real data but *different* real data (e.g. other similar flavor variables in your dataset, an entirely different dataset with similar flavors of variables or data types like data frame or lists).
  
  iii) Use on weird stuff. Here you are trying to break your function. Use NAs, values outside of range, different flavors, different data types. 
  
  iv) Use automated tests! See the `testthat` package and the R packages book section on [testing](http://r-pkgs.had.co.nz/tests.html ). Looks too complicated to throw in the mix right now, but likely very useful to follow up on in the future.
  
```{r Function ex step 5}
# Test on some different possible data
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
x <- c(1:10, Inf)
rescale01(x) #Huh, this is an issue...

# But easy to fix now that we have code in a working function!
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)

# Seems ok, so now can use on your original dataset
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```
  
6. Based on results of step 5, ensure your function fails noisily and as soon as possible and insert informative error messages. See section below. Also note that you can skip this step if you are not intending to re-use your function; no sense in just making extra work for yourself.

## Making functions fail and writing informative error messages
It is important to check the validity of your arguments so you are aware if your function is not behaving as expected. It is also very helpful if you write in useful error messages, rather than generic ones, as otherwise it can get tricky (especially for future you that has forgotten all about this function) to figure out why something suddenly isn't working any more. 

* `stopifnot` is useful entry-level solution as it evaluates (T or F) if the input is what you think it is, and stops the function if the evaluation = F. It does not provide a very helpful error message though. Important to remember that you are putting what you want to be TRUE inside the function.
```{r stopifnot ex}
mmm <- function(x) {
  stopifnot(is.numeric(x))
  max(x) - min(x)
}
mmm(gapminder$lifeExp)
mmm("eggplants are purple")
```

* `if` and then `stop` is another option for evaluting inputs. This option lets you write a more informative error message, but important to remember you are writing what you do NOT want to happen inside your 'if' statement.
```{r if then stop ex}
mmm2 <- function(x) {
  if(!is.numeric(x)) {
    stop('I am so sorry, but this function only works for numeric input!\n',
         'You have provided an object of class: ', class(x)[1])
  }
  max(x) - min(x)
}
mmm2(gapminder)
```




Notes on how to return output from a function

Notes on default values

## For and While Loops
STILL NEED TO PUT NOTES IN HERE

* length of loops: you can use either `i in 1:length(x)` or `i in seq_along(x)`. The latter is probably safer, as length can sometimes lead to unexpected results.


## Functional programing with Purrr
LOOK AT DATA CAMP SLIDES?